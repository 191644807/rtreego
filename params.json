{"google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"rtreego","tagline":"an R-Tree library for Go","body":"rtreego\r\n=======\r\n\r\nA library for efficiently storing and querying spatial data\r\nin the Go programming language.\r\n\r\n\r\nAbout\r\n-----\r\n\r\nThe R-tree is a popular data structure for efficiently storing and\r\nquerying spatial objects; one common use is implementing geospatial\r\nindexes in database management systems.  The variant implemented here,\r\nknown as the R*-tree, improves performance and increases storage\r\nutilization.  Both bounding-box queries and k-nearest-neighbor queries\r\nare supported.\r\n\r\nR-trees are balanced, so maximum tree height is guaranteed to be\r\nlogarithmic in the number of entries; however, good worst-case\r\nperformance is not guaranteed.  Instead, a number of rebalancing\r\nheuristics are applied that perform well in practice.  For more\r\ndetails please refer to the references.\r\n\r\n\r\nStatus\r\n------\r\n\r\nThe geometric primitives, basic algorithms (insertion, deletion), and\r\nqueries (bounding-box, nearest-neighbor) are implemented and tested.\r\n\r\nThis implementation handles the general N-dimensional case; for a more\r\nefficient implementation for the 3-dimensional case, see [Patrick\r\nHiggins' fork](https://github.com/patrick-higgins/rtreego).\r\n\r\n\r\nInstall\r\n-------\r\n\r\nWith Go 1 installed, just run `go get github.com/dhconnelly/rtreego`.\r\n\r\n\r\nUsage\r\n-----\r\n\r\nMake sure you `import github.com/dhconnelly/rtreego` in your Go source files.\r\n\r\n### Storing, updating, and deleting objects\r\n\r\nTo create a new tree, specify the number of spatial dimensions and the minimum\r\nand maximum branching factor:\r\n\r\n\trt := rtreego.NewTree(2, 25, 50)\r\n\r\nAny type that implements the `Spatial` interface can be stored in the tree:\r\n\r\n\ttype Spatial interface {\r\n\t\tBounds() *Rect\r\n\t}\r\n\r\n`Rect`s are data structures for representing spatial objects, while `Point`s\r\nrepresent spatial locations.  Creating `Point`s is easy--they're just slices\r\nof `float64`s:\r\n\r\n\tp1 := rtreego.Point{0.4, 0.5}\r\n\tp2 := rtreego.Point{6.2, -3.4}\r\n\r\nTo create a `Rect`, specify a location and the lengths of the sides:\r\n\r\n\tr1 := rtreego.NewRect(p1, []float64{1, 2})\r\n\tr2 := rtreego.NewRect(p2, []float64{1.7, 2.7})\r\n\r\nTo demonstrate, let's create and store some test data.\r\n\r\n\ttype Thing struct {\r\n\t\twhere *Rect\r\n\t\tname string\r\n\t}\r\n\t\r\n\tfunc (t *Thing) Bounds() *Rect {\r\n\t\treturn t.where\r\n\t}\r\n\t\r\n\trt.Insert(&Thing{r1, \"foo\"})\r\n\trt.Insert(&Thing{r2, \"bar\"})\r\n\t\r\n\tsize := rt.Size() // returns 2\r\n\r\nWe can insert and delete objects from the tree in any order.\r\n\r\n\trt.Delete(thing2)\r\n\t// do some stuff...\r\n\trt.Insert(anotherThing)\r\n\r\nIf you want to store points instead of rectangles, you can easily convert a\r\npoint into a rectangle using the `ToRect` method:\r\n\r\n\tvar tol = 0.01\r\n\r\n\ttype Somewhere struct {\r\n\t\tlocation rtreego.Point\r\n\t\tname string\r\n\t\twormhole chan int\r\n\t}\r\n\t\r\n\tfunc (s *Somewhere) Bounds() *Rect {\r\n\t\t// define the bounds of s to be a rectangle centered at s.location\r\n\t\t// with side lengths 2 * tol:\r\n\t\treturn s.location.ToRect(tol)\r\n\t}\r\n\t\r\n\trt.Insert(&Somewhere{rtreego.Point{0, 0}, \"Someplace\", nil})\r\n\r\nIf you want to update the location of an object, you must delete it, update it,\r\nand re-insert.  Just modifying the object so that the `*Rect` returned by \r\n`Location()` changes, without deleting and re-inserting the object, will\r\ncorrupt the tree.\r\n\r\n### Queries\r\n\r\nBounding-box and k-nearest-neighbors queries are supported.\r\n\r\nBounding-box queries require a search `*Rect` argument and come in two flavors:\r\ncontainment search and intersection search.  The former returns all objects that\r\nfall strictly inside the search rectangle, while the latter returns all objects\r\nthat touch the search rectangle.\r\n\r\n\tbb := rtreego.NewRect(rtreego.Point{1.7, -3.4}, []float64{3.2, 1.9})\r\n\r\n\t// Get a slice of the objects in rt that intersect bb:\r\n\tresults, _ := rt.SearchIntersect(bb)\r\n\r\n\t// Get a slice of the objects in rt that are contained inside bb:\r\n\tresults, _ = rt.SearchContained(bb)\r\n\r\nNearest-neighbor queries find the objects in a tree closest to a specified\r\nquery point.\r\n\r\n\tq := rtreego.Point{6.5, -2.47}\r\n\tk := 5\r\n\r\n\t// Get a slice of the k objects in rt closest to q:\r\n\tresults, _ = rt.SearchNearestNeighbors(q, k)\r\n\r\n### More information\r\n\r\nSee http://gopkgdoc.appspot.com/pkg/github.com/dhconnelly/rtreego for full API documentation.\r\n\r\n\r\nReferences\r\n----------\r\n\r\n- A. Guttman.  R-trees: A Dynamic Index Structure for Spatial Searching.\r\n  Proceedings of ACM SIGMOD, pages 47-57, 1984.\r\n  http://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Guttman84.pdf\r\n  \r\n- N. Beckmann, H .P. Kriegel, R. Schneider and B. Seeger.  The R*-tree: An\r\n  Efficient and Robust Access Method for Points and Rectangles.  Proceedings\r\n  of ACM SIGMOD, pages 323-331, May 1990.\r\n  http://infolab.usc.edu/csci587/Fall2011/papers/p322-beckmann.pdf\r\n  \r\n- N. Roussopoulos, S. Kelley and F. Vincent.  Nearest Neighbor Queries.  ACM\r\n  SIGMOD, pages 71-79, 1995.\r\n  http://www.postgis.org/support/nearestneighbor.pdf\r\n\r\n\r\nAuthor\r\n------\r\n\r\nrtreego is written and maintained by Daniel Connelly.  You can find my stuff\r\nat dhconnelly.com or email me at dhconnelly@gmail.com.\r\n\r\n\r\nLicense\r\n-------\r\n  \r\nrtreego is released under a BSD-style license; see LICENSE for more details.\r\n"}