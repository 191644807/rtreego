<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>rtreego by dhconnelly</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">rtreego</h1>
        <p class="header">an R-Tree library for Go</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/dhconnelly/rtreego/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/dhconnelly/rtreego/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/dhconnelly/rtreego">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/dhconnelly">dhconnelly</a></p>


      </header>
      <section>
        <h1>
<a name="rtreego" class="anchor" href="#rtreego"><span class="octicon octicon-link"></span></a>rtreego</h1>

<p>A library for efficiently storing and querying spatial data
in the Go programming language.</p>

<h2>
<a name="about" class="anchor" href="#about"><span class="octicon octicon-link"></span></a>About</h2>

<p>The R-tree is a popular data structure for efficiently storing and
querying spatial objects; one common use is implementing geospatial
indexes in database management systems.  The variant implemented here,
known as the R*-tree, improves performance and increases storage
utilization.  Both bounding-box queries and k-nearest-neighbor queries
are supported.</p>

<p>R-trees are balanced, so maximum tree height is guaranteed to be
logarithmic in the number of entries; however, good worst-case
performance is not guaranteed.  Instead, a number of rebalancing
heuristics are applied that perform well in practice.  For more
details please refer to the references.</p>

<p>This implementation handles the general N-dimensional case; for a more
efficient implementation for the 3-dimensional case, see <a href="https://github.com/patrick-higgins/rtreego">Patrick
Higgins' fork</a>.</p>

<h2>
<a name="getting-started" class="anchor" href="#getting-started"><span class="octicon octicon-link"></span></a>Getting Started</h2>

<p>Get the source code from <a href="https://github.com/dhconnelly/rtreego">GitHub</a> or,
with Go 1 installed, run <code>go get github.com/dhconnelly/rtreego</code>.</p>

<p>Make sure you <code>import github.com/dhconnelly/rtreego</code> in your Go source files.</p>

<h2>
<a name="documentation" class="anchor" href="#documentation"><span class="octicon octicon-link"></span></a>Documentation</h2>

<h3>
<a name="storing-updating-and-deleting-objects" class="anchor" href="#storing-updating-and-deleting-objects"><span class="octicon octicon-link"></span></a>Storing, updating, and deleting objects</h3>

<p>To create a new tree, specify the number of spatial dimensions and the minimum
and maximum branching factor:</p>

<pre><code>rt := rtreego.NewTree(2, 25, 50)
</code></pre>

<p>Any type that implements the <code>Spatial</code> interface can be stored in the tree:</p>

<pre><code>type Spatial interface {
    Bounds() *Rect
}
</code></pre>

<p><code>Rect</code>s are data structures for representing spatial objects, while <code>Point</code>s
represent spatial locations.  Creating <code>Point</code>s is easy--they're just slices
of <code>float64</code>s:</p>

<pre><code>p1 := rtreego.Point{0.4, 0.5}
p2 := rtreego.Point{6.2, -3.4}
</code></pre>

<p>To create a <code>Rect</code>, specify a location and the lengths of the sides:</p>

<pre><code>r1 := rtreego.NewRect(p1, []float64{1, 2})
r2 := rtreego.NewRect(p2, []float64{1.7, 2.7})
</code></pre>

<p>To demonstrate, let's create and store some test data.</p>

<pre><code>type Thing struct {
    where *Rect
    name string
}

func (t *Thing) Bounds() *Rect {
    return t.where
}

rt.Insert(&amp;Thing{r1, "foo"})
rt.Insert(&amp;Thing{r2, "bar"})

size := rt.Size() // returns 2
</code></pre>

<p>We can insert and delete objects from the tree in any order.</p>

<pre><code>rt.Delete(thing2)
// do some stuff...
rt.Insert(anotherThing)
</code></pre>

<p>If you want to store points instead of rectangles, you can easily convert a
point into a rectangle using the <code>ToRect</code> method:</p>

<pre><code>var tol = 0.01

type Somewhere struct {
    location rtreego.Point
    name string
    wormhole chan int
}

func (s *Somewhere) Bounds() *Rect {
    // define the bounds of s to be a rectangle centered at s.location
    // with side lengths 2 * tol:
    return s.location.ToRect(tol)
}

rt.Insert(&amp;Somewhere{rtreego.Point{0, 0}, "Someplace", nil})
</code></pre>

<p>If you want to update the location of an object, you must delete it, update it,
and re-insert.  Just modifying the object so that the <code>*Rect</code> returned by
<code>Location()</code> changes, without deleting and re-inserting the object, will
corrupt the tree.</p>

<h3>
<a name="queries" class="anchor" href="#queries"><span class="octicon octicon-link"></span></a>Queries</h3>

<p>Bounding-box and k-nearest-neighbors queries are supported.</p>

<p>Bounding-box queries require a search <code>*Rect</code> argument and come in two flavors:
containment search and intersection search.  The former returns all objects that
fall strictly inside the search rectangle, while the latter returns all objects
that touch the search rectangle.</p>

<pre><code>bb := rtreego.NewRect(rtreego.Point{1.7, -3.4}, []float64{3.2, 1.9})

// Get a slice of the objects in rt that intersect bb:
results, _ := rt.SearchIntersect(bb)

// Get a slice of the objects in rt that are contained inside bb:
results, _ = rt.SearchContained(bb)
</code></pre>

<p>Nearest-neighbor queries find the objects in a tree closest to a specified
query point.</p>

<pre><code>q := rtreego.Point{6.5, -2.47}
k := 5

// Get a slice of the k objects in rt closest to q:
results, _ = rt.SearchNearestNeighbors(q, k)
</code></pre>

<h3>
<a name="more-information" class="anchor" href="#more-information"><span class="octicon octicon-link"></span></a>More information</h3>

<p>See <a href="http://gopkgdoc.appspot.com/pkg/github.com/dhconnelly/rtreego">GoPkgDoc</a>
for full API documentation.</p>

<h2>
<a name="references" class="anchor" href="#references"><span class="octicon octicon-link"></span></a>References</h2>

<ul>
<li><p>A. Guttman.  R-trees: A Dynamic Index Structure for Spatial Searching.
Proceedings of ACM SIGMOD, pages 47-57, 1984.
<a href="http://www.cs.jhu.edu/%7Emisha/ReadingSeminar/Papers/Guttman84.pdf">http://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Guttman84.pdf</a></p></li>
<li><p>N. Beckmann, H .P. Kriegel, R. Schneider and B. Seeger.  The R*-tree: An
Efficient and Robust Access Method for Points and Rectangles.  Proceedings
of ACM SIGMOD, pages 323-331, May 1990.
<a href="http://infolab.usc.edu/csci587/Fall2011/papers/p322-beckmann.pdf">http://infolab.usc.edu/csci587/Fall2011/papers/p322-beckmann.pdf</a></p></li>
<li><p>N. Roussopoulos, S. Kelley and F. Vincent.  Nearest Neighbor Queries.  ACM
SIGMOD, pages 71-79, 1995.
<a href="http://www.postgis.org/support/nearestneighbor.pdf">http://www.postgis.org/support/nearestneighbor.pdf</a></p></li>
</ul><h2>
<a name="author" class="anchor" href="#author"><span class="octicon octicon-link"></span></a>Author</h2>

<p>Written by <a href="http://dhconnelly.com">Daniel Connelly</a> (<a href="mailto:dhconnelly@gmail.com">dhconnelly@gmail.com</a>).</p>

<h2>
<a name="license" class="anchor" href="#license"><span class="octicon octicon-link"></span></a>License</h2>

<p>rtreego is released under a BSD-style license, described here and in the
<code>LICENSE</code> file:</p>

<p>Copyright (c) 2012, Daniel Connelly. All rights reserved.</p>

<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:</p>

<ol>
<li><p>Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.</p></li>
<li><p>Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.</p></li>
<li><p>Neither the name of Daniel Connelly nor the names of its contributors may be
used to endorse or promote products derived from this software without
specific prior written permission.</p></li>
</ol><p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		
  </body>
</html>