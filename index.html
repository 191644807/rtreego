<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>rtreego by dhconnelly</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>rtreego</h1>
        <p>an R-Tree library for Go</p>

        <p class="view"><a href="https://github.com/dhconnelly/rtreego">View the Project on GitHub <small>dhconnelly/rtreego</small></a></p>


        <ul>
          <li><a href="https://github.com/dhconnelly/rtreego/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/dhconnelly/rtreego/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/dhconnelly/rtreego">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>rtreego</h1>

<p>A library for efficiently storing and querying spatial data
in the Go programming language.</p>

<h2>About</h2>

<p>The R-tree is a popular data structure for efficiently storing and
querying spatial objects; one common use is implementing geospatial
indexes in database management systems.  The variant implemented here,
known as the R*-tree, improves performance and increases storage
utilization.  Both bounding-box queries and k-nearest-neighbor queries
are supported.</p>

<p>R-trees are balanced, so maximum tree height is guaranteed to be
logarithmic in the number of entries; however, good worst-case
performance is not guaranteed.  Instead, a number of rebalancing
heuristics are applied that perform well in practice.  For more
details please refer to the references.</p>

<h2>Status</h2>

<p>The geometric primitives, basic algorithms (insertion, deletion), and
queries (bounding-box, nearest-neighbor) are implemented and tested.</p>

<p>This implementation handles the general N-dimensional case; for a more
efficient implementation for the 3-dimensional case, see <a href="https://github.com/patrick-higgins/rtreego">Patrick
Higgins' fork</a>.</p>

<h2>Install</h2>

<p>With Go 1 installed, just run <code>go get github.com/dhconnelly/rtreego</code>.</p>

<h2>Usage</h2>

<p>Make sure you <code>import github.com/dhconnelly/rtreego</code> in your Go source files.</p>

<h3>Storing, updating, and deleting objects</h3>

<p>To create a new tree, specify the number of spatial dimensions and the minimum
and maximum branching factor:</p>

<pre><code>rt := rtreego.NewTree(2, 25, 50)
</code></pre>

<p>Any type that implements the <code>Spatial</code> interface can be stored in the tree:</p>

<pre><code>type Spatial interface {
    Bounds() *Rect
}
</code></pre>

<p><code>Rect</code>s are data structures for representing spatial objects, while <code>Point</code>s
represent spatial locations.  Creating <code>Point</code>s is easy--they're just slices
of <code>float64</code>s:</p>

<pre><code>p1 := rtreego.Point{0.4, 0.5}
p2 := rtreego.Point{6.2, -3.4}
</code></pre>

<p>To create a <code>Rect</code>, specify a location and the lengths of the sides:</p>

<pre><code>r1 := rtreego.NewRect(p1, []float64{1, 2})
r2 := rtreego.NewRect(p2, []float64{1.7, 2.7})
</code></pre>

<p>To demonstrate, let's create and store some test data.</p>

<pre><code>type Thing struct {
    where *Rect
    name string
}

func (t *Thing) Bounds() *Rect {
    return t.where
}

rt.Insert(&amp;Thing{r1, "foo"})
rt.Insert(&amp;Thing{r2, "bar"})

size := rt.Size() // returns 2
</code></pre>

<p>We can insert and delete objects from the tree in any order.</p>

<pre><code>rt.Delete(thing2)
// do some stuff...
rt.Insert(anotherThing)
</code></pre>

<p>If you want to store points instead of rectangles, you can easily convert a
point into a rectangle using the <code>ToRect</code> method:</p>

<pre><code>var tol = 0.01

type Somewhere struct {
    location rtreego.Point
    name string
    wormhole chan int
}

func (s *Somewhere) Bounds() *Rect {
    // define the bounds of s to be a rectangle centered at s.location
    // with side lengths 2 * tol:
    return s.location.ToRect(tol)
}

rt.Insert(&amp;Somewhere{rtreego.Point{0, 0}, "Someplace", nil})
</code></pre>

<p>If you want to update the location of an object, you must delete it, update it,
and re-insert.  Just modifying the object so that the <code>*Rect</code> returned by 
<code>Location()</code> changes, without deleting and re-inserting the object, will
corrupt the tree.</p>

<h3>Queries</h3>

<p>Bounding-box and k-nearest-neighbors queries are supported.</p>

<p>Bounding-box queries require a search <code>*Rect</code> argument and come in two flavors:
containment search and intersection search.  The former returns all objects that
fall strictly inside the search rectangle, while the latter returns all objects
that touch the search rectangle.</p>

<pre><code>bb := rtreego.NewRect(rtreego.Point{1.7, -3.4}, []float64{3.2, 1.9})

// Get a slice of the objects in rt that intersect bb:
results, _ := rt.SearchIntersect(bb)

// Get a slice of the objects in rt that are contained inside bb:
results, _ = rt.SearchContained(bb)
</code></pre>

<p>Nearest-neighbor queries find the objects in a tree closest to a specified
query point.</p>

<pre><code>q := rtreego.Point{6.5, -2.47}
k := 5

// Get a slice of the k objects in rt closest to q:
results, _ = rt.SearchNearestNeighbors(q, k)
</code></pre>

<h3>More information</h3>

<p>See <a href="http://gopkgdoc.appspot.com/pkg/github.com/dhconnelly/rtreego">http://gopkgdoc.appspot.com/pkg/github.com/dhconnelly/rtreego</a> for full API documentation.</p>

<h2>References</h2>

<ul>
<li><p>A. Guttman.  R-trees: A Dynamic Index Structure for Spatial Searching.
Proceedings of ACM SIGMOD, pages 47-57, 1984.
<a href="http://www.cs.jhu.edu/%7Emisha/ReadingSeminar/Papers/Guttman84.pdf">http://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Guttman84.pdf</a></p></li>
<li><p>N. Beckmann, H .P. Kriegel, R. Schneider and B. Seeger.  The R*-tree: An
Efficient and Robust Access Method for Points and Rectangles.  Proceedings
of ACM SIGMOD, pages 323-331, May 1990.
<a href="http://infolab.usc.edu/csci587/Fall2011/papers/p322-beckmann.pdf">http://infolab.usc.edu/csci587/Fall2011/papers/p322-beckmann.pdf</a></p></li>
<li><p>N. Roussopoulos, S. Kelley and F. Vincent.  Nearest Neighbor Queries.  ACM
SIGMOD, pages 71-79, 1995.
<a href="http://www.postgis.org/support/nearestneighbor.pdf">http://www.postgis.org/support/nearestneighbor.pdf</a></p></li>
</ul><h2>Author</h2>

<p>rtreego is written and maintained by Daniel Connelly.  You can find my stuff
at dhconnelly.com or email me at <a href="mailto:dhconnelly@gmail.com">dhconnelly@gmail.com</a>.</p>

<h2>License</h2>

<p>rtreego is released under a BSD-style license; see LICENSE for more details.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/dhconnelly">dhconnelly</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>